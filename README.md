# go_pool

## Описание

Этот проект реализует примитивный worker-pool на языке Go с возможностью динамического добавления и удаления воркеров. Входные данные (строки) поступают в канал, а воркеры их обрабатывают, выводя на экран свой уникальный идентификатор и полученные данные. Проект демонстрирует базовые знания каналов и горутин в Go.

## Структура проекта

```
go_pool/
├── cmd/
│   └── workers/
│       └── main.go
└── printer/
    └── printer.go
```

- **`cmd/workers/main.go`**: Главная точка входа в приложение.
- **`printer/printer.go`**: Реализация worker-pool и обработчиков строк.

## Требования

- **Go** версии **1.13** или выше.
- Интернет-соединение для загрузки зависимостей при первом запуске `go mod tidy`.

## Сборка и запуск

### 1. Инициализация модулей

Перейдите в корневую директорию проекта и выполните команду:

```bash
go mod tidy
```

Это загрузит все необходимые зависимости и создаст файлы `go.mod` и `go.sum`, если их еще нет.

### 2. Запуск приложения

Для запуска приложения выполните команду:

```bash
go run ./cmd/workers/main.go
```

Если вы хотите скомпилировать приложение в исполняемый файл, используйте:

```bash
go build -o worker_pool ./cmd/workers/main.go
```

Затем запустите исполняемый файл:

```bash
./worker_pool
```

## Ожидаемый вывод

При запуске программы вы увидите вывод, где каждый воркер обрабатывает входящие строки:

```
worker_uuid: c56a4180-65aa-42ec-a945-5fd21dec0538 msg: aBcDeFgHiJ
worker_uuid: 1f4e9f3c-3b6b-4b6e-b5b6-8c5e1d5f6a7b msg: kLmNoPqRsT
...
```

Когда вы остановите программу (например, нажав **Ctrl+C**), она корректно завершит работу всех воркеров:

```
worker c56a4180-65aa-42ec-a945-5fd21dec0538 stopped
stopping application with signal: interrupt
ended work
```

## Детали реализации

### **printer/printer.go**

- **Пакет `printer`**: Содержит логику для управления воркерами и обработки строк.
- **Структура `StringHandler`**:
  - **Поля**:
    - `limit`: Максимальное количество воркеров.
    - `active`: Текущее количество активных воркеров.
    - `queue`: Канал для передачи строк воркерам.
    - `gStop`: Функция для отмены контекста.
    - `starter`: `sync.Once` для обеспечения однократного запуска.
    - `ctx`: Контекст для управления жизненным циклом воркеров.
  - **Методы**:
    - `New()`: Конструктор для создания нового `StringHandler`.
    - `Start()`: Запускает воркеры.
    - `GracefulStop()`: Корректно останавливает все воркеры.
    - `AddWorkers(amount int)`: Добавляет воркеры.
    - `DeleteWorkers(amount int)`: Уменьшает количество активных воркеров.
    - `Handle(task string)`: Добавляет задачу в очередь.
    - `handler()`: Функция воркера для обработки строк.

### **cmd/workers/main.go**

- **Функция `main()`**:
  - Инициализирует контекст и создает экземпляр `StringHandler` с 10 воркерами.
  - Запускает генератор задач `taskCreator`.
  - Ожидает системного сигнала для корректного завершения работы.
- **Функция `taskCreator()`**:
  - Генерирует случайные строки и отправляет их в обработку.
  - Работает в отдельной горутине.
- **Функция `generateRandomString(n int)`**:
  - Создает случайную строку длиной `n` из буквенно-цифровых символов.

## Обработка сигналов

Приложение обрабатывает системные сигналы `SIGTERM` и `SIGINT` для корректного завершения работы. При получении сигнала все воркеры завершаются, и приложение выводит сообщение о завершении.

## Как добавить или удалить воркеры

- **Добавление воркеров**:

  Вызовите метод `AddWorkers(amount int)` у экземпляра `StringHandler`, передав количество воркеров для добавления.

  ```go
  sh.AddWorkers(5) // Добавит 5 воркеров
  ```

- **Удаление воркеров**:

  Вызовите метод `DeleteWorkers(amount int)` у экземпляра `StringHandler`, указав количество воркеров для удаления.

  ```go
  sh.DeleteWorkers(3) // Уменьшит лимит воркеров на 3
  ```

## Дополнительные сведения

- **Уникальные идентификаторы**: Каждый воркер получает уникальный UUID с помощью `github.com/google/uuid`.
- **Синхронизация**: Используется `sync.Once` для гарантии однократного запуска воркеров.
- **Потокобезопасность**: Использование контекстов и каналов обеспечивает безопасное взаимодействие между горутинами.
